<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wildfire Data Visualizations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
        }
        .chart-container {
            margin: 20px auto;
            width: 90%;
            text-align: center;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            border-radius: 3px;
            pointer-events: none;
            font-size: 12px;
        }
        #filter-container {
            margin: 20px auto;
            text-align: center;
        }
        select {
            padding: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="filter-container">
        <label for="year-filter">Select Year: </label>
        <select id="year-filter"></select>
    </div>

    <div class="chart-container" id="barChart"></div>
    <div class="chart-container" id="scatterPlot"></div>
    <div class="chart-container" id="lineChart"></div>
    <div class="chart-container" id="pieChart"></div>

    <script>
        const csvUrl = "./areaburntbywildfiresbyweek.csv"; // Update with your dataset path

        d3.csv(csvUrl).then(data => {
            
            const years = Object.keys(data[0]).filter(d => d.startsWith("area burnt"));
            const processedData = data.map(d => {
                const yearlyData = years.map(year => ({
                    year: +year.match(/\d+/)[0],
                    value: +d[year],
                    entity: d.Entity
                }));
                return { entity: d.Entity, code: d.Code, yearlyData };
            });

            // Populate year filter dropdown
            const yearFilter = d3.select("#year-filter");
            years.forEach(year => {
                yearFilter.append("option").text(year.match(/\d+/)[0]).attr("value", year);
            });

            // visualization default
            const defaultYear = years[0];

            createBarChart(processedData, years);
            createScatterPlot(processedData, [defaultYear]);
            createLineChart(processedData);
            createPieChart(processedData, [defaultYear]);

            // Update visualizations when year changes
            yearFilter.on("change", function () {
                const selectedYear = this.value;
                d3.select("#scatterPlot").selectAll("*").remove();
                d3.select("#pieChart").selectAll("*").remove();
                createScatterPlot(processedData, [selectedYear]);
                createPieChart(processedData, [selectedYear]);
            });
        });

        // Chart functions (integrated from earlier examples)
        function createBarChart(data, years) {
            const svg = d3.select("#barChart")
                .append("svg")
                .attr("width", 800)
                .attr("height", 500);

            const yearlySums = years.map(year => ({
                year: +year.match(/\d+/)[0],
                total: d3.sum(data, d => d.yearlyData.find(y => y.year == year).value)
            }));

            const xScale = d3.scaleBand()
                .domain(yearlySums.map(d => d.year))
                .range([50, 750])
                .padding(0.2);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(yearlySums, d => d.total)])
                .nice()
                .range([450, 50]);

            svg.append("g")
                .attr("transform", "translate(0,450)")
                .call(d3.axisBottom(xScale).tickFormat(d3.format("d")));

            svg.append("g")
                .attr("transform", "translate(50,0)")
                .call(d3.axisLeft(yScale));

            svg.selectAll(".bar")
                .data(yearlySums)
                .join("rect")
                .attr("class", "bar")
                .attr("x", d => xScale(d.year))
                .attr("y", d => yScale(d.total))
                .attr("width", xScale.bandwidth())
                .attr("height", d => 450 - yScale(d.total))
                .attr("fill", "steelblue");

            svg.append("text")
                .attr("x", 400)
                .attr("y", 30)
                .attr("text-anchor", "middle")
                .style("font-size", "18px")
                .style("font-weight", "bold")
                .text("Total Area Burnt by Wildfires Over Time");
        }

        function createScatterPlot(data, years) {
            const year = years[0]; // Use the first year from the array
            const selectedData = data.map(d => {
                const yearlyEntry = d.yearlyData.find(y => y.year === +year.match(/\d+/)[0]);
                return { entity: d.entity, value: yearlyEntry.value };
            });

            const svg = d3.select("#scatterPlot")
                .append("svg")
                .attr("width", 800)
                .attr("height", 500);

            const xScale = d3.scaleLinear()
                .domain([0, d3.max(selectedData, d => d.value)])
                .range([50, 750]);

            const yScale = d3.scaleBand()
                .domain(selectedData.map(d => d.entity))
                .range([50, 450])
                .padding(0.1);

            svg.append("g")
                .attr("transform", "translate(0,450)")
                .call(d3.axisBottom(xScale));

            svg.append("g")
                .attr("transform", "translate(50,0)")
                .call(d3.axisLeft(yScale));

            svg.selectAll(".circle")
                .data(selectedData)
                .join("circle")
                .attr("cx", d => xScale(d.value))
                .attr("cy", d => yScale(d.entity) + yScale.bandwidth() / 2)
                .attr("r", 8)
                .attr("fill", "orange");
        }

        function createLineChart(data) {
            const svg = d3.select("#lineChart")
                .append("svg")
                .attr("width", 800)
                .attr("height", 500);

            const xScale = d3.scaleLinear()
                .domain([2012, 2024])
                .range([50, 750]);

            const yScale = d3.scaleLinear()
                .domain([0, d3.max(data, d => d3.max(d.yearlyData, y => y.value))])
                .nice()
                .range([450, 50]);

            svg.append("g")
                .attr("transform", "translate(0,450)")
                .call(d3.axisBottom(xScale).tickFormat(d3.format("d")));

            svg.append("g")
                .attr("transform", "translate(50,0)")
                .call(d3.axisLeft(yScale));

            const line = d3.line()
                .x(d => xScale(d.year))
                .y(d => yScale(d.value));

            svg.selectAll(".line")
                .data(data)
                .join("path")
                .attr("d", d => line(d.yearlyData))
                .attr("fill", "none")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 2);
        }

        function createPieChart(data, years) {
            const year = years[0];
            const selectedData = data.map(d => {
                const yearlyEntry = d.yearlyData.find(y => y.year === +year.match(/\d+/)[0]);
                return { entity: d.entity, value: yearlyEntry.value };
            });

            const svg = d3.select("#pieChart")
                .append("svg")
                .attr("width", 800)
                .attr("height", 500)
                .append("g")
                .attr("transform", "translate(400,250)");

            const radius = 200;

            const pie = d3.pie().value(d => d.value);
            const arc = d3.arc().innerRadius(0).outerRadius(radius);

            svg.selectAll(".arc")
                .data(pie(selectedData))
                .join("path")
                .attr("d", arc)
                .attr("fill", (d, i) => d3.schemeCategory10[i % 10]);
        }
    </script>
</body>
</html>
